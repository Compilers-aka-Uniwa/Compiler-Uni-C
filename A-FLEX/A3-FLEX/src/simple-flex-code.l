/* File name:            simple-flex-code.l
   Description:          Template for developing a lexical analyzer using the Flex tool
   Author:               Compiler Laboratory, Department of Computer Engineering and Informatics,
                         University of West Attica
   Comments:             This program implements (using flex) a simple lexical analyzer
                         that recognizes whitespace (space and tab) and numbers
                         (decimal system only!) for the Uni-C language, while handling
                         special characters such as newline '\n' (new line) and 'EOF'
                         (end of file). There are references for recognizing variables,
                         with the actual code replaced by the lexical placeholder FILL ME
                         so that it can be completed by you. Optionally, the lexical
                         analyzer accepts file arguments for input and output.
   Execution instructions: Type "make" (without quotes) in the current directory. Alternatively:
                         flex -o simple-flex-code.c simple-flex-code.l
                         gcc -o simple-flex-code simple-flex-code.c
                         ./simple-flex-code
*/

/* Input is limited to a single file and terminates at the first EOF */
%option noyywrap


/* C code for defining the required header files and variables.
   Anything between %{ and %} is automatically copied into the C file
   generated by Flex. */

%{

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* Header file that contains the list of all tokens */
#include "token.h"

/* Definition of current line counter */
int line = 1;

%}


/* Names and corresponding definitions (in the form of regular expressions).
   After this point, the names (left) can be used instead of the
   particularly long and hard-to-read regular expressions */

DELIMITER        [;]
IDENTIFIER       [a-zA-Z_][a-zA-Z0-9_]{0,31}
STRING           \"([^"\\]*(\\[\\n"][^"\\]*)*)\"
INTEGER          ([1-9][0-9]*|0[x|X][0-9A-F]+|0[0-7]+|0)
FLOAT            (?:[1-9][0-9]*|0)(?:\.(?:[1-9][0-9]*|0*[1-9]+))?(?:[eE](?:-?[1-9][0-9]*|0))?
KEYWORD          (break|case|const|continue|do|double|else|float|for|if|int|long|return|sizeof|struct|switch|void|while|func)
OPERATOR         (\+|-|\*|\/|%|=|\+=|-=-|\*=|\/=|!|&&|\|\||==|!=|\+\+|--|<|>|<=|>=|&|\||\^|<<|>>|&)
COMMENT          (\/\/.*\n|\/\*[^*]*\*+([^/*][^*]*\*+)*\/)
WHITESPACE       [ \t]+
NEWLINE          [\n]
UNKNOWN          [^ \t\r\n;]+


/* For each pattern (left) that matches, the corresponding
   code inside the braces is executed. The return statement allows
   returning a numeric value via the yylex() function */

%%

{DELIMITER}     { return DELIMITER; }
{IDENTIFIER}    { return IDENTIFIER; }
{STRING}        { return STRING; }
{INTEGER}       { return INTEGER; }
{FLOAT}         { return FLOAT; }
{KEYWORD}       { return KEYWORD; }
{OPERATOR}      { return OPERATOR; }
{COMMENT}       { ECHO; line++; }
{WHITESPACE}    { }
{NEWLINE}       { return NEWLINE; }
<<EOF>>         { return END_OF_FILE; }
{UNKNOWN}       { return UNKNOWN; }

%%

/* Table with all tokens corresponding to the definitions in token.h */
char *tname[] = {
   "DELIMITER", 
   "IDENTIFIER", 
   "STRING", 
   "INTEGER", 
   "FLOAT", 
   "KEYWORD", 
   "OPERATOR", 
   "NEWLINE", 
   "END_OF_FILE", 
   "UNKNOWN" 
};


/* The main function: The following code will automatically be placed
   into the C program generated by Flex and will be the entry point
   of the lexical analyzer application */

int main(int argc, char **argv){
        int token;

        /* Command-line argument checking. If there are 3 arguments,
           the program reads from the file given by the 2nd argument
           and writes to the file given by the 3rd. If there are 2
           arguments, it reads from the file given by the 2nd argument
           and writes to the screen. It is assumed that the 1st argument
           (argv[0]) in C is the name of the executable file itself. */

        if(argc == 3){
                if(!(yyin = fopen(argv[1], "r"))) {
                        fprintf(stderr, "Cannot read file: %s\n", argv[1]);
                        return 1;
                }
                if(!(yyout = fopen(argv[2], "w"))) {
                        fprintf(stderr, "Cannot create file: %s\n", argv[2]);
                        return 1;
                }
        }
        else if(argc == 2){
                if(!(yyin = fopen(argv[1], "r"))) {
                        fprintf(stderr, "Cannot read file: %s\n", argv[1]);
                        return 1;
                }
        }

        /* The yylex function reads characters from the input and tries
           to recognize tokens. The tokens it recognizes are those
           defined in this file between the %% and %%. If the code
           corresponding to a pattern contains the instruction
           'return VALUE', yylex() returns that value and stores it
           in the variable token. */

        while( (token=yylex()) >= 0){
                /* For each recognized token, the line in which it was found
                   and its name along with its value are printed. */
                if (token)
                {
                  switch(token) 
                  {
                     case NEWLINE: 
                        line++;
                        break;
                     case END_OF_FILE:
                        fprintf(yyout, "\tLine=%d, token=%s, value=\"%s\"\n", line, tname[token-1], yytext);
                        printf("#END-OF-FILE#\n");
                        exit(0);
                        break;
                     case UNKNOWN:
                        fprintf(yyout, "\tLine=%d, token=%s TOKEN, value=\"%s\"\n", line, tname[token-1], yytext);
                        break;
                     default:
                        fprintf(yyout, "\tLine=%d, token=%s, value=\"%s\"\n", line, tname[token-1], yytext);
                        break;
                  } 
                }
                
        }
        return 0;
}
