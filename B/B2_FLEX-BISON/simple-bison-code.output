Terminals unused in grammar

    STRING
    FLOAT
    BREAK
    DO
    IF
    SIZEOF
    CASE
    STRUCT
    FUNC
    ELSE
    SWITCH
    CONST
    RETURN
    VOID
    CONTINUE
    FOR
    WHILE
    MUL_EQ
    POST_MIN_EQ
    MINUS
    DIV_EQ
    LESS
    MUL
    NOT
    GREATER
    DIV
    AND
    LESS_EQ
    MOD
    OR
    GREATER_EQ
    ASSIGN_OP
    EQUAL
    ADDR_OP
    PLUS_EQ
    NOT_EQ
    MIN_EQ
    POST_PLUS_EQ
    END_OF_FILE
    OPEN_SQ_BRACKETS
    CLOSE_SQ_BRACKETS
    OPEN_CURLY_BRACKETS
    CLOSE_CURLY_BRACKETS
    BACKSLASH
    UNKNOWN
    MULT


Grammar

    0 $accept: program $end

    1 $@1: ε

    2 program: program expr NEWLINE $@1 program decl NEWLINE
    3        | ε

    4 decl: type var DELIMITER

    5 type: INT
    6     | FLOAT_KEY
    7     | DOUBLE
    8     | SHORT
    9     | LONG

   10 var: IDENTIFIER
   11    | var COMMA IDENTIFIER

   12 expr: INTEGER
   13     | expr PLUS expr


Terminals, with rules where they appear

    $end (0) 0
    error (256)
    IDENTIFIER (258) 10 11
    STRING (259)
    INTEGER (260) 12
    FLOAT (261)
    BREAK (262)
    DO (263)
    IF (264)
    SIZEOF (265)
    CASE (266)
    DOUBLE (267) 7
    INT (268) 5
    STRUCT (269)
    FUNC (270)
    ELSE (271)
    LONG (272) 9
    SWITCH (273)
    CONST (274)
    FLOAT_KEY (275) 6
    RETURN (276)
    VOID (277)
    CONTINUE (278)
    FOR (279)
    SHORT (280) 8
    WHILE (281)
    PLUS (282) 13
    MUL_EQ (283)
    POST_MIN_EQ (284)
    MINUS (285)
    DIV_EQ (286)
    LESS (287)
    MUL (288)
    NOT (289)
    GREATER (290)
    DIV (291)
    AND (292)
    LESS_EQ (293)
    MOD (294)
    OR (295)
    GREATER_EQ (296)
    ASSIGN_OP (297)
    EQUAL (298)
    ADDR_OP (299)
    PLUS_EQ (300)
    NOT_EQ (301)
    MIN_EQ (302)
    POST_PLUS_EQ (303)
    DELIMITER (304) 4
    NEWLINE (305) 2
    END_OF_FILE (306)
    OPEN_SQ_BRACKETS (307)
    CLOSE_SQ_BRACKETS (308)
    OPEN_CURLY_BRACKETS (309)
    CLOSE_CURLY_BRACKETS (310)
    COMMA (311) 11
    BACKSLASH (312)
    UNKNOWN (313)
    MULT (314)


Nonterminals, with rules where they appear

    $accept (60)
        on left: 0
    program (61)
        on left: 2 3
        on right: 0 2
    $@1 (62)
        on left: 1
        on right: 2
    decl (63)
        on left: 4
        on right: 2
    type (64)
        on left: 5 6 7 8 9
        on right: 4
    var (65)
        on left: 10 11
        on right: 4 11
    expr (66)
        on left: 12 13
        on right: 2 13


State 0

    0 $accept: • program $end

    $default  reduce using rule 3 (program)

    program  go to state 1


State 1

    0 $accept: program • $end
    2 program: program • expr NEWLINE $@1 program decl NEWLINE

    $end     shift, and go to state 2
    INTEGER  shift, and go to state 3

    expr  go to state 4


State 2

    0 $accept: program $end •

    $default  accept


State 3

   12 expr: INTEGER •

    $default  reduce using rule 12 (expr)


State 4

    2 program: program expr • NEWLINE $@1 program decl NEWLINE
   13 expr: expr • PLUS expr

    PLUS     shift, and go to state 5
    NEWLINE  shift, and go to state 6


State 5

   13 expr: expr PLUS • expr

    INTEGER  shift, and go to state 3

    expr  go to state 7


State 6

    2 program: program expr NEWLINE • $@1 program decl NEWLINE

    $default  reduce using rule 1 ($@1)

    $@1  go to state 8


State 7

   13 expr: expr • PLUS expr
   13     | expr PLUS expr •

    $default  reduce using rule 13 (expr)


State 8

    2 program: program expr NEWLINE $@1 • program decl NEWLINE

    $default  reduce using rule 3 (program)

    program  go to state 9


State 9

    2 program: program • expr NEWLINE $@1 program decl NEWLINE
    2        | program expr NEWLINE $@1 program • decl NEWLINE

    INTEGER    shift, and go to state 3
    DOUBLE     shift, and go to state 10
    INT        shift, and go to state 11
    LONG       shift, and go to state 12
    FLOAT_KEY  shift, and go to state 13
    SHORT      shift, and go to state 14

    decl  go to state 15
    type  go to state 16
    expr  go to state 4


State 10

    7 type: DOUBLE •

    $default  reduce using rule 7 (type)


State 11

    5 type: INT •

    $default  reduce using rule 5 (type)


State 12

    9 type: LONG •

    $default  reduce using rule 9 (type)


State 13

    6 type: FLOAT_KEY •

    $default  reduce using rule 6 (type)


State 14

    8 type: SHORT •

    $default  reduce using rule 8 (type)


State 15

    2 program: program expr NEWLINE $@1 program decl • NEWLINE

    NEWLINE  shift, and go to state 17


State 16

    4 decl: type • var DELIMITER

    IDENTIFIER  shift, and go to state 18

    var  go to state 19


State 17

    2 program: program expr NEWLINE $@1 program decl NEWLINE •

    $default  reduce using rule 2 (program)


State 18

   10 var: IDENTIFIER •

    $default  reduce using rule 10 (var)


State 19

    4 decl: type var • DELIMITER
   11 var: var • COMMA IDENTIFIER

    DELIMITER  shift, and go to state 20
    COMMA      shift, and go to state 21


State 20

    4 decl: type var DELIMITER •

    $default  reduce using rule 4 (decl)


State 21

   11 var: var COMMA • IDENTIFIER

    IDENTIFIER  shift, and go to state 22


State 22

   11 var: var COMMA IDENTIFIER •

    $default  reduce using rule 11 (var)
